#!usr/bin/env python

from codon_translation import codon_map, start_codon, stop_codons


def translateCodon(x):
    # turn into upper case:
    codon = x.upper()
    # check if the codon is in the amino acid dictionary:
    if codon in codon_map:
        # return the aminoacid by looking up in the dictionary:
        return codon_map[codon]
    else:
        # return '?' if we could not translate the codon:
        return '?'


def splitCodons(orf):
    # make sure the sequence length is a multiple of three:
    assert not len(orf) % 3
    # define a list for the results to be returned from the function:
    result = []
    # loop over a list of indexes generated by range.
    # from 0 to, but not including, len(orf), in jumps of 3
    for i in range(0, len(orf), 3):
        result.append(orf[i:i+3])
    return result


def translateSequence(orf):
    # split orf into codons:
    codons = splitCodons(orf)
    # define a string of amino acids to add to:
    aaString = ''
    # loop over the codons:
    for codon in codons:
        # translate the codon and add it to the growing amino acid string:
        aaString += translateCodon(codon)
    # return the string:
    return aaString


def findStartPositions(seq):
    # uppercase seq
    seq = seq.upper()
    # define a list for the results
    result = []
    # loop over all indexes of seq unless the last two (where codons can not start):
    for i in range(len(seq)-2):
        # check if the codon is the start codon (notice the slicing technique):
        if seq[i:i+3] == start_codon:
            # append the start codon position to the list:
            result.append(i)
    # return the list
    return result


def findNextCodon(seq, start, codon):
    # loop over a list of indexes generated by range.
    # from start to, but not including, len(seq), in jumps of 3    
    for i in range(start, len(seq), 3):
        # check if the current position is the start codon we look for:
        if seq[i:i+3] == codon:
            # return the start position of thet codon - ending the function:
            return i
    # If we get this far it means that we did not find the codon we where looking for so
    # we return None. However, a function that does not explicitly return something
    # defaults to returning None. So it is not scrictly necessary
    return None


def findNextStopCodon(seq, start):
    # uppercase the sequence:
    seq = seq.upper()
    # define a list for temporary restults:
    results = []
    # loop over the different stop codons:
    for stopCodon in stop_codons:
        # find the start position of the next stop codon:
        pos = findNextCodon(seq, start, stopCodon)
        # check that pos is not None, which would indicate that the codon was not found:
        if pos != None:
            # append the start position of the codon to the list of temporary retults.
            results.append(pos)
    if len(results) > 0:
        # if we found the position of one or more stop codons we return the smallest (closet) one:
        return min(results)
    else:
        # if we did not find any stop codons we return None
        return None


def findOpenReadingFrames(seq):
    # define a list to add results to:
    result = []
    # loop over the list of start positions returned by findStartPositions:
    for startPosition in findStartPositions(seq):
        # get the stop position for each start position:
        stopPosition = findNextStopCodon(seq, startPosition)
        # check that we actually found a stop positions:
        if stopPosition != None:
            # append a tuple with start and stop positiosn to the list:
            result.append( (startPosition, stopPosition) )
    # return the list:
    return result


def findAndTranslateOpenReadingFrames(seq):
    # uppercase seq:
    seq = seq.upper()
    # define a list to add results to:
    result = []
    # loop over the list of start, stop tuples returned from findOpenReadingFrames:
    for start, stop in findOpenReadingFrames(seq):
        # slice out the appropriate part of the sequence:
        orf = seq[start:stop+3]
        # append a translation fo the org to the list of results:
        result.append(translateSequence(orf))
    # return the list:
    return result

        

if __name__ == "__main__":

    f = open('sample_sequences.txt', 'r')
    sequences = list()
    for line in f:
        seq = line.strip()
        sequences.append(seq)
    f.close()

    seq = sequences[0]

    print translateCodon("ACG")
    print splitCodons('ATGCTTTAG')
    print translateSequence('ATGCTTTAG')
    print findStartPositions(seq)
    print findNextCodon(seq, 0, "ACG")
    print findNextStopCodon(seq, 0)
    print findOpenReadingFrames(seq)
    print findAndTranslateOpenReadingFrames(seq)        





